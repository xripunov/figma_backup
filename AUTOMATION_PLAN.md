# План по автоматизации резервного копирования Figma (Версия 2.1)

Этот документ описывает план по настройке ежедневного автоматического запуска бэкапа для **каждой группы файлов индивидуально**.

## Общая концепция

Мы реализуем автоматизацию через URL-схему. Приложение будет "слушать" специальную ссылку, содержащую идентификатор группы (`figma-bckp://start-backup/{groupId}`). Системный планировщик `launchd` будет "открывать" эту ссылку по заданному пользователем расписанию, тем самым запуская процесс бэкапа для конкретной группы.

Вся настройка будет производиться пользователем из интерфейса приложения для каждой группы отдельно.

---

## Часть 1: Изменения в приложении

1.  **Динамическая URL-схема:** Вместо одной статической ссылки будет использоваться параметризованная, чтобы точно знать, какую группу бэкапить.
    *   **Формат:** `figma-bckp://start-backup/{groupId}`
    *   **Пример:** `figma-bckp://start-backup/group_1a2b3c`

2.  **Добавление зависимости:** В `pubspec.yaml` будет добавлен пакет `uni_links` для работы с URL-схемами.

3.  **Регистрация URL-схемы:** В `macos/Runner/Info.plist` будут добавлены строки, которые сообщат macOS, что ссылки вида `figma-bckp://` должно обрабатывать наше приложение.

4.  **UI для управления автоматизацией (`HomeScreen`):**
    *   В карточку каждой группы, над списком файлов, будет добавлен виджет для управления автоматизацией.
    *   Он будет состоять из переключателя (`Switch`) и текстового статуса ("Выключен" или "Ежедневно в 21:00").
    *   При включении будет появляться стандартный диалог выбора времени.

5.  **UI для сводной информации (`SettingsScreen`):**
    *   На экране настроек появится **read-only** раздел "Расписание бэкапов", где будет выведен список всех групп с включенной автоматизацией и их расписание.

6.  **Сценарий автозапуска:** Логика в Dart при запуске по URL-схеме будет выполнять следующий сценарий:
    *   Приложение запускается или выходит на передний план.
    *   Из URL извлекается `{groupId}`.
    *   **Проверяется флаг `isBackupInProgress` (см. Часть 3). Если он `true`, запуск игнорируется.**
    *   Если система свободна, флаг устанавливается в `true`.
    *   Приложение переходит на экран бэкапа, автоматически запуская процесс для группы с полученным `groupId`.

7.  **Обновление модели данных:** В модель `BackupGroup` (`lib/models/backup_group.dart`) будут добавлены поля для хранения состояния автоматизации, например: `bool isAutomationEnabled` и `TimeOfDay automationTime`.

---

## Часть 2: Реализация автоматической настройки

Для каждой группы с включенной автоматизацией будет создаваться отдельная задача в `launchd`.

1.  **Динамическая генерация `.plist` файла:** Когда пользователь включает автоматизацию для группы, приложение создает в памяти `.plist` файл для `launchd`.

    ```xml
    <?xml version="1.0" encoding="UTF8"?>
    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
    <plist version="1.0">
    <dict>
        <key>Label</key>
        <string>com.figma_bckp.scheduler.group_1a2b3c</string> <!-- Уникальный Label -->
        <key>ProgramArguments</key>
        <array>
            <string>open</string>
            <string>figma-bckp://start-backup/group_1a2b3c</string> <!-- Уникальный URL -->
        </array>
        <key>StartCalendarInterval</key>
        <dict>
            <key>Hour</key>
            <integer>21</integer> <!-- Время из настроек -->
            <key>Minute</key>
            <integer>0</integer>
        </dict>
    </dict>
    </plist>
    ```

2.  **Сохранение файла:** Приложение сохраняет файл по пути `~/Library/LaunchAgents/com.figma_bckp.scheduler.{groupId}.plist`.

3.  **Активация/Деактивация:**
    *   **Включение:** Выполняется shell-команда `launchctl load ...` для активации задачи.
    *   **Отключение:** Выполняется `launchctl unload ...` и последующее удаление `.plist` файла.

---

## Часть 3: Обработка крайних случаев и параллелизма

Для предотвращения конфликтов и гонки состояний вводится строгая и простая политика.

1.  **Принцип "Один бэкап за раз":** Система может выполнять только один процесс резервного копирования в любой момент времени. Очередь задач **не реализуется** для максимального упрощения.

2.  **Механизм блокировки:** Вводится глобальный флаг состояния `isBackupInProgress`.
    *   Перед началом любого бэкапа (ручного или автоматического) приложение проверяет этот флаг.
    *   Если `isBackupInProgress` равен `true`, новый запуск **полностью игнорируется**.
    *   Если `false`, флаг немедленно устанавливается в `true` и процесс начинается.
    *   После завершения процесса (успешно, с ошибкой или будучи прерванным пользователем) флаг в блоке `finally` **гарантированно** сбрасывается в `false`.

3.  **Важное архитектурное ограничение:**
    *   Процесс бэкапа **не отвязан от UI**. Он привязан к жизненному циклу экрана `BackupScreen`.
    *   Если пользователь уходит с экрана `BackupScreen` (например, нажимая "Назад"), процесс бэкапа **прерывается**.
    *   Критически важно, чтобы в логике прерывания (например, в методе `dispose` экрана) флаг `isBackupInProgress` корректно сбрасывался в `false`, освобождая систему для следующих задач.

---

## Часть 4: Синхронизация состояния с системой

Чтобы UI приложения всегда отражал реальное положение дел, необходимо синхронизировать внутреннее состояние (`isAutomationEnabled`) с фактическим состоянием задачи в `launchd`.

1.  **Механизм проверки:** Для проверки статуса конкретной задачи будет использоваться shell-команда.
    ```bash
    launchctl list | grep com.figma_bckp.scheduler.{groupId}
    ```
    *   Если команда возвращает непустой результат, задача активна.
    *   Если результат пустой, задача в `launchd` отсутствует.

2.  **Точка синхронизации:** Проверка будет выполняться в ключевой момент — **при запуске приложения и загрузке настроек**.
    *   `SettingsService` при загрузке данных будет итерироваться по всем группам, у которых в настройках стоит `isAutomationEnabled = true`.
    *   Для каждой такой группы будет выполнена команда проверки.
    *   **Если проверка покажет, что задача в `launchd` на самом деле отсутствует**, сервис принудительно обновит состояние группы в приложении (`isAutomationEnabled = false`).

3.  **Результат:** Такой подход гарантирует, что приложение "самоисцеляется" от рассинхронизации. Пользователь в интерфейсе всегда будет видеть актуальный статус автоматизации, даже если `.plist` файл был удален вручную или задача не загрузилась по системным причинам.